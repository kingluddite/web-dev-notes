# Consuming Actions in Reducers
* In the last section we fleshed out our Action Creator `selectBook` by return an `action` from it with a **type** and a **payload**

```js
export function selectBook(book) {
  return {
    type: 'BOOK_SELECTED',
    payload: book
  };
}
```

![diagram](https://i.imgur.com/X3pIsG2.png)

* We are now at the `Action automatically sent to all reducers`
* This is possible because we wired up our `BookList` as a Container, the result of the **Action Creator** is being automatically sent to the list of all of our `reducers`

## Last Step - Create our ActiveBook Reducer
* Create a new file `src/reducers/ReducerActiveBook.js`

### arguments to reducers
* All reducers get two arguments

1. The current state (`state`)
2. `action`

```js
export default function(state, action) {

}
```

* **note** `reducers` are only ever called when an `action` occurs (_the `state`, on the other hand, is a little more nebulous/confusing_)

## state in reducer
`State` argument is not Application `state`, only the `state` this `reducer` is responsible for

### What do we mean by this?
```js
const rootReducer = combineReducers({
  books: BooksReducer
});
```

* `BooksReducers` is only responsible to provide value for `books` key
* The `state` that gets passed as an argument for that `BooksReducer` is only the `state` that was previously generated by the `BooksReducer` (So the same `state` that is being produced by these `reducers`) is flowing back into it whenever an action occurs

```js
export default function(state, action) {
  state += 1
}
```

* **note** Simple example above (just trying to give an idea how `state` works with `reducers`)
* Assume that state is just a number (it is really an object) but let's say it was 1, the next time it came in it would already be 1 and the same state comes in and then it gets updated to 2 and then the next time 3... Rinse and repeat. When `state` gets updated it is NOT the Application `state`

* Our `reducer` is going to get called whenever an action is **dispatched** by our Application
* This means our `reducer` will be called all the time
* Lots of times when the `action` doesn't concern any particular `reducer` at any time so to handle a case where the `action` is **dispatched** that we don't care about we really need a **base case** to return the **current state** (_in other words if we don't care about the **current action** just pass the `state` back through_)

## The case where we DON'T CARE about the `action`
`src/reducers/ReducerActiveBook.js`

```js
export default function(state, action) {
  return state;
}
```

## The case were we DO CARE about the `action`
** **note** Most Redux `reducers` are set up JavaScript `switch` statements where the `switch` statement is going to look at the `action` **type** and if it is one that we care about, we'll return a new `state`

`src/reducers/ReducerActiveBook.js`

```js
export default function(state, action) {
  switch(action.type)  {
    case 'BOOK_SELECTED':
      return action.payload
  }
  
  return state;
}
```

* I our switch statment we only care about the `BOOK_SELECTED` case and if that is the action.type
* Then we'll return `action.payload` which is the `selectedBook`

## App first boots up
* We need to handle the case when our Application first boots up and no book is immediately selected, and if that happens and the user hasn't clicked on it we just `return state`

```js
export default function(state, action) {
  switch(action.type)  {
    case 'BOOK_SELECTED':
      return action.payload
  }
  
  return state; // we just return state here when the Application 
                // first boots up
}
```

* But right now our `reducer` would return `undefined`. Redux won't allow us to return `undefined` from a `reducer
* It will throw an error

**rule** We must ALWAYS return a non-`undefined` value

## How can we handle this case?
* We will default the value of the `state` argument to `null`
* This is ES6 syntax which allows us to give our function arguments default values

```js
export default function(state = null, action) {
  switch(action.type)  {
    case 'BOOK_SELECTED':
      return action.payload
  }

  return state;
}
```

### Review
* Our reducer is looking good
* If the action has a type of BOOK_SELECTED we'll return the book that was selected (action.payload)
* If the action is anything else we just return the current state

#### Here's an example of what not to do:
**important** We should never mutate our current state to produce a new version of the state
The object that we return from our reducer must always be 100% fresh and clean

`src/reducers/ReducerActiveBook.js`

```js
export default function(state = null, action) {
  switch(action.type)  {
    case 'BOOK_SELECTED':
      // DON'T DO THIS!!!
      state.title = book.title
  }

  return state;
}
```

* Our reducers need to be connected into the `combineReducers()`

`src/reducers/index.js`

```js
import { combineReducers } from 'redux';
import BooksReducer from './ReducerBooks';

const rootReducer = combineReducers({
  books: BooksReducer
});

export default rootReducer;
```

### Import our ActiveBook reducer
```js
import { combineReducers } from 'redux';
import BooksReducer from './ReducerBooks';
import ActiveBook from './ReducerActiveBook'; // add this line

const rootReducer = combineReducers({
  books: BooksReducer
});

export default rootReducer;
```

### Add ActiveBook to combineReducers
* As another piece of `state`

```js
import { combineReducers } from 'redux';
import BooksReducer from './ReducerBooks';
import ActiveBook from './ReducerActiveBook';

const rootReducer = combineReducers({
  books: BooksReducer,
  activeBook: ActiveBook
});

export default rootReducer;
```

**note** Any `key` we provide to our `combineReducers()` ends up as a `key` on our global `state` (_Application `state`_)

![diagram](https://i.imgur.com/e2MLn3g.png)

* We created a reducer that caught the **BOOK_SELECTED** `action` and returned the payload
* The `selectedBook` will now end up as the value for `activeBook` on our `state`

### Next
* Verify that we set everything up correctly
